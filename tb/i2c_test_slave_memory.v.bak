//`timescale 1 ns / 1 ps


module testbench();
reg sys_clk, rstn;

parameter ADDRESSLENGTH = 8;
parameter ADDRESSNUM = 2;
parameter NBYTES = 2;


reg Enable = 1'b0;
reg Mode = 1'b1;
reg RorW = 1'b1;
reg [ADDRESSLENGTH-1: 0] DirectionBuffer = 8'b00001111;
reg AddressFound = 1'b0;
reg [8*NBYTES*ADDRESSNUM: 0 ]Data;
reg [7:0]OutputBuffer;
wire [7:0]InputBuffer = 8'b0;
wire [((ADDRESSLENGTH)*ADDRESSNUM) - 1: 0]AddressList = 16'b0000111100001110;



I2C_SLAVE_MEMORY #( ADDRESSLENGTH, ADDRESSNUM, NBYTES) i2c_slave_memory(Enable, Mode, RorW, DirectionBuffer, InputBuffer, OutputBuffer, AddressFound, AddressList, Data);


//SPI spi_1(rstn, sys_clk, t_start, d_in, t_size, d_out, miso, mosi, spi_clk, cs, state);




//Prueba de la memoria
initial begin
#10; //Comprovamos que no disponemos de esta dirección y la bandera no se pone en alto
DirectionBuffer = 8'b00011111;
Mode = 1'b0;
#10;
Enable = 1'b1;
#10
DirectionBuffer = 8'b00001111;//Dirección correcta
Enable = 1'b0;
#10;
Enable = 1'b1;
#10;
Enable = 1'b0;
#10;//Comprovamos el modulo de escritura
Mode = 1'b1;
InputBuffer = 8'b01010101;
RorW = 1'b1;
#10;
Enable = 1'b1;//Escribimos
#10;
Enable = 1'b0;//Vamos a añadir otro dato en la memoria
InputBuffer = 8'b11110101;
#10;




end




endmodule



