/*
	Autor: Albert Espiña Rojas
	Modulo: I2C_SLAVE_UC

*/

module I2C_SLAVE_UC #( parameter ADDRESSLENGTH)(Sda, Scl, HaveAddress, DirectionBuffer, InputBuffer, OutputBuffer, RorW, MemoryEnable, start, state);
	inout wire Sda;//Pin de datos entre el maestro y los esclavos
	output wire Scl;//Pin de reloj entre el maestro y el esclavo
	input HaveAddress;//Input de la memoria para indicar que el dispositivo tiene la dirección de memoria solicitada
	output reg [(ADDRESSLENGTH-1): 0] DirectionBuffer; //Buffer para guardar la dirección que solicita el master
	output reg [7:0]InputBuffer; //Bufer donde irán todos los datos guardadosa a la memoria
	input wire [7:0]OutputBuffer;// Buffer donde irán todos los datos recibidos
	output reg RorW = 1'b0; //Estado 0 lectura, estado 1 escritura
	

	output reg state = 1'b0;//Estado 0 cuando el master está solicitando conexión. Estado 1, cuando hay transferencia
	output reg MemoryEnable = 1'b0; //Registro para activar la comunicación etre la memoria y la unidad de control
	
	output reg start = 1'b0;//Estado para activar el dispositivo slave
	integer Counter = 1'b0;//Contador de los bits del Sda, 
	
	reg sda_intern = 1'b1;

assign Sda = ( sda_intern ) ? 1'bz : 1'b0;

	
always @(negedge Sda) begin //Condición de start
	if (Scl) begin 
		Counter <= 0;
		start <= 1'b1;
		state <= 1'b0;
		RorW <= 1'b0;
		MemoryEnable <= 1'b0;
	end
end
always @(posedge Sda) begin //Condición de stop
	if (Scl) start <= 1'b0;
end
always @(posedge Scl) begin
	if (start) begin
		if (state) begin
			if (Counter < 8) begin//las transferencias son de byte a byte, por lo tanto hay que tener el contador también
				if (RorW) InputBuffer[Counter] <= Sda; //guardamos el dato en el buffer ya que estamos recibiendo
				Counter <= Counter + 1;	
				MemoryEnable <= 0;
			end
			if (Counter == 8) begin //fin del byte de datos, hay que mirar si hemos recibido un ack o un nack en el caso de modo escritura
				if (!RorW) MemoryEnable <= !Sda; //Si tenemos un 1 es un Nack y por lo tanto podemos pedir el siguiente dato
				else MemoryEnable <= 1;
				Counter <= 0;	
			end
		
		end
		else begin
			if (Counter < ADDRESSLENGTH) begin //Recibiendo los datos de la dirección de memoria
				DirectionBuffer[Counter] <= Sda;
				Counter <= Counter + 1;
			end
			else if (Counter == ADDRESSLENGTH) begin //Al siguiente ciclo el master especificará si la tranasferencia es read or write
				RorW <= Sda;
				Counter <= Counter + 1;
			end 
			else if ((Counter == ADDRESSLENGTH + 1) && HaveAddress) begin //Al siguiente ciclo el master especificará si la tranasferencia es read or write
				Counter <= 0;
				if (!RorW) MemoryEnable <= 1;
				state <= 1'b1;
			end 
			else begin
				Counter <= 0;
				start <= 0; //En caso de que la transferencia no sea con este dispositivo, lo desactivamos
			end
		end
	end
end

always @(negedge Scl) begin
/*
	El flanco de bajada del clock está destinado para que el slave envíe datos a través del Sda, cuando sea necesario
*/
	sda_intern <= 1;
	if (state) begin
		//En este caso enviamos ráfagas de 8 bits y esperamos a recibir el ack si estamos escribiendo
		if (Counter < 8 && !RorW) sda_intern <= OutputBuffer[Counter];
		 //fin del byte de datos, hay enviar o recibir un ack y de paso guardamos el buffer en la memoria
		else if (Counter == 8 && RorW) sda_intern <= 1'b0;//modo lectura, enviamos nosotros un ack
	end
	else begin
		if (Counter == ADDRESSLENGTH + 1 && HaveAddress) sda_intern <= 1'b0;
	end
end
endmodule